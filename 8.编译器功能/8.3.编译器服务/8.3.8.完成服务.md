# 8.3.8.完成服务

要获得最佳的编译和完成速度，你可以使用 --wait 命令行参数来启动一个 Haxe 完成服务。你也可以使用 -v 来使服务打印日志。这里是一个例子：

```
haxe -v --wait 6000
```

然后你可以连接到Haxe服务器，发送命令行参数后跟一个 0 字节，再然后，读取响应（完成结果或者错误信息）。

使用 --connect 命令行参数使Haxe 发送它的完成命令到服务器，而不是直接执行它们：

```
haxe --connect 6000 myproject.hxml 
```

注意，你可以在第一次发送命令行的时候使用 --cwd 参数，改变Haxe服务器的当前工作目录。通常，类路径和其它的文件跟你的项目是相关的。

它如何工作 完成服务会缓存下面的东西：
**解析的文件** 文件只有在它们被修改或者出现一个解析错误的时候才会再次被解析
**haxelib 调用** 前面的haxelib调用的结果可以被重用（只用于完成：它们在做编译时是被忽略的）
**类型的模块** 编译模块在一个成功的编译后会被缓存，并且如果它们的依赖关系没有被修改，则可以在之后的 编译/完成 中重用

你可以了解编译器花费的精确时间，和如何使用完成服务影响它们，通过添加 --times 到命令行即可。

**协议** 如下面的Haxe/Neko示例展示的，你可以简单的连接到服务端口，并发送所有的命令（或者每行）以0二进制字符结束。然后就可以读取结果。

宏和其它的命令可以记录不是错误的事件。从命令行中，我们可以看到 stdout 打印的和stderr打印的内容的不同。这不是sockt模式下的情况。为了区分两者，日志消息（不是错误消息）前置一个 x01 字符，消息中所有的换行符都被同样的 x01 字符取代。

警告和其它的消息也可以被认为是错误，但是是不致命的。如果一个不致命的错误发生，它会发送一个单行的 x02 消息行。

这里是一些将连接到服务并处理协议细节的代码：

```haxe
class Test { 
    static function main() { 
        var newline = "\textbackslash\ n"; 
        var s = new neko.net.Socket(); 
        s.connect(new neko.net.Host("127.0.0.1"),6000); 
        s.write("--cwd /my/project" + newline); 
        s.write("myproject.hxml" + newline); 
        s.write("\textbackslash\ 000"); 
        
        var hasError = false; 
        for (line in s.read().split(newline)) 
        { 
            switch (line.charCodeAt(0)) { 1
                case 0x01: 
                    neko.Lib.print(line.substr(1).split("\ textbackslash\ x01").join(newline)); 
                case 0x02: 
                    hasError = true; 
                default: 
                    neko.io.File.stderr().writeString(line + newline); 
            } 
        } 
        if (hasError) neko.Sys.exit(1); 
    } 
}
```

**对宏的影响** 完成服务可能对宏的执行（第9章）有一些副作用。

