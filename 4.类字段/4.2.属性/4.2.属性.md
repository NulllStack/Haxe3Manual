# 4.2.属性

变量下面，属性是第二个选项来处理类中的数据。然而不像变量，它们提供更多的控制哪种类型的字段访问被允许，和它如何被生成。通常用处包括：

> Next to variables (4.1), properties are the second option for dealing with data on a class. Unlike variables however, they offer more control of which kind of ﬁeld access should be allowed and how it should be generated. Common use cases include:

- 有一个可以被从任何地方读取，但是只能被从定义类写入的字段
- 有一个调用一个getter方法获得读权限的字段
- 有一个调用一个setter方法获得写入权限的字段

> - Have a ﬁeld which can be read from anywhere,but only be written from within the deﬁning class.
> - Have a ﬁeld which invokes a getter-method upon read-access.
> - Have a ﬁeld which invokes a setter-method upon write-access.

当处理属性时，重要的是理解两种类型的访问：

> When dealing with properties, it is important to understand the two kinds of access:

> 定义：读取访问
>  一个字段的读取访问发生在右手字段访问表达式（第5.7节）使用时。包括通过 obj.field() 形式调用来访问授权读取的字段。
>  定义：写入访问
>  一个字段的写入访问发生在一个字段访问表达式被以obj.field=value格式赋一个值的时候。也可能和读取访问联合出现，对于特别的赋值操作符如 += ，表达式形如 obj.field += value 。
>  [warning] Deﬁnition: Read Access
>  A read access to a ﬁeld occurs when a right-hand side ﬁeld access expression (5.7) is used. This includes calls in the form of obj.field(), where field is accessed to be read.

> Deﬁnition: Write Access
>  A write access to a ﬁeld occurs when a ﬁeld access expression (5.7) is assigned a value in the form of obj.field = value. It may also occur in combination with read access (4.2) for special assignment operators such as += in expressions like obj.field += value.

读取访问和写入访问直接反映在语法形式，如下面的例子：

> Read access and write access are directly reﬂected in the syntax, as the following example shows:

```haxe
class Main {
    public var x(default, null):Int; 
    static public function main() { } 
} 
```

多数情况，和变量的语法类似，实际上适用同样的规则。属性被识别，通过

> For the most part, the syntax is similar to variable syntax, and the same rules indeed apply. Properties are identiﬁed by

- 字段名后开口的括号 ( ，
- 后面跟一个特定的访问标识符（这里是 default），
- 逗号，隔开
- 另一个特殊的访问标识符（这里是null），
- 和一个闭口的括号 )

> - the opening parenthesis ( after the ﬁeld name,
> - followed by a special access identiﬁer (here: default),
> - with a comma , separating
> - another special access identiﬁer (here: null)
> - before a closing parenthesis ).

访问标识符定义当字段被读取（第一个标识符）的行为，和写入的行为（第二个标识符）。接受的值为：

> The access identiﬁers deﬁne the behavior when the ﬁeld is read (ﬁrst identiﬁer) and written (second identiﬁer). The accepted values are:

**default**：如果字段有公开的可见性，则允许普通的字段访问，否则等于 null 访问。
**null**：只允许从定义的类中访问。
**get/set**：访问被生成为一个存取器方法。编译器确保存取器可用。
**dynamic**：类似get/set访问，但是不验证存取器字段的存在。
**never**：不允许访问

> **default**: Allows normal ﬁeld access if the ﬁeld has public visibility, otherwise equal to null access.
> **null**: Allows access only from within the deﬁning class.
> **get/set**: Access is generated as a call to an accessor method. The compiler ensures that the accessor is available.
> **dynamic**: Like get/set access, but does not verify the existence of the accessor ﬁeld.
> **never**: Allows no access at all.

**存取器方法**

> 定义：存取器方法
>  一个T类型名为 filed 的字段的一个存取器方法（或者简称为存取器）是一个Void->T类型名为 get_field 的 getter，或者T->T类型名为 set_field的setter。
>  [warning] Deﬁnition: Accessor method
>  An accessor method (or short accessor) for a ﬁeld named field of type T is a getter named get_field of type Void->T or a setter named set_field of type T->T.

**存取器名称**

> 花絮：存取器名称
>  在Haxe 2中，任意的标识符允许作为访问标识符，可以使定制的存取器方法名是被认可的。这使得部分实现非常难以处理。特别是，Reflect.getProperty() 和 Reflect.setProterty() 必须假定任何名称可能被使用，需要目标生成器生成元信息和执行查找。我们不允许这些标识符，而使用 get_ 和 set_ 命名约定，大大简化了实现。这是Haxe2 和Haxe 3之间一个阻断式的变更。
>  [warning] Trivia: Accessor names
>  In Haxe 2, arbitrary identiﬁers were allowed as access identiﬁers and would lead to custom accessor method names to be admitted. This made parts of the implementation quite tricky todealwith. In particular,Reflect.getProperty() and Reflect.setProperty() had to assume that any name could have been used, requiring the target generators to generate meta-information and perform lookups. We disallowed these identiﬁers and went for the get_ and set_ naming convention which greatly simpliﬁed implementation. This was one of the breaking changes between Haxe 2 and 3.