# 4.2.属性

在变量字段之后，属性字段是第二个用来处理类中的数据的选项。不像变量字段，属性字段可以对允许何种类型的字段的访问，以及如何被生成提供更多控制权，通常有以下使用场景：

> Next to variables (4.1), properties are the second option for dealing with data on a class. Unlike variables however, they offer more control of which kind of ﬁeld access should be allowed and how it should be generated. Common use cases include:

- 需要一个可以被从任何地方读取，但是只能从定义所在的类内部进行写入的字段
- 需要调用一个 getter 方法获得读取权限的字段
- 需要调用一个 setter 方法获得写入权限的字段

> - Have a ﬁeld which can be read from anywhere,but only be written from within the deﬁning class.
> - Have a ﬁeld which invokes a getter-method upon read-access.
> - Have a ﬁeld which invokes a setter-method upon write-access.

面对属性字段时，重要的是理解以下两种类型的访问：

> When dealing with properties, it is important to understand the two kinds of access:

> **定义** 读取访问：
> 一个字段的读取访问发生于 右值（right-hand side) [字段访问表达式（第5.7节）](/5.表达式/5.7.字段访问)被使用时。其中包括了通过 `obj.field()` 形式的调用，此时字段 `field` 发生了读取访问。
>
> **定义** 写入访问：
> 一个字段的写入访问发生于使用字段访问表达式进行赋值时，比如 `obj.field = value` 。当使用 `+=` 等特殊的赋值操作符的同时，也会发生读取访问，比如表达式 `obj.field += value`。
>
> [warning] Deﬁnition: Read Access
> A read access to a ﬁeld occurs when a right-hand side ﬁeld access expression (5.7) is used. This includes calls in the form of obj.field(), where field is accessed to be read.
>
> Deﬁnition: Write Access
> A write access to a ﬁeld occurs when a ﬁeld access expression (5.7) is assigned a value in the form of obj.field = value. It may also occur in combination with read access (4.2) for special assignment operators such as += in expressions like obj.field += value.

读取访问和写入访问直接反映在语法形式上，如下面的例子：

> Read access and write access are directly reﬂected in the syntax, as the following example shows:

```haxe
class Main {
    public var x(default, null):Int; 
    static public function main() { } 
} 
```

多数情况，和变量的语法类似，实际上适用同样的规则。但是属性字段的声明有以下特征：

> For the most part, the syntax is similar to variable syntax, and the same rules indeed apply. Properties are identiﬁed by

- 字段名称后跟开口的括号 `(`
- 后跟一个特定的访问标识符（此例为：`default`），
- 一个逗号 `,` 进行分隔
- 后跟另一个特殊的访问标识符（此例为：`null`），
- 最后闭口括号 `)` 进行闭合

> - the opening parenthesis ( after the ﬁeld name,
> - followed by a special access identiﬁer (here: default),
> - with a comma , separating
> - another special access identiﬁer (here: null)
> - before a closing parenthesis ).

访问标识符定义了字段的读取（第一个标识符）行为，和写入（第二个标识符）行为。有以下标识符可用：

> The access identiﬁers deﬁne the behavior when the ﬁeld is read (ﬁrst identiﬁer) and written (second identiﬁer). The accepted values are:

- `default`：如果字段修饰为 `public` 则具备通常的访问权限，否则等于 `null` 标识符。
- `null`：只允许从定义的类内部进行访问。
- `get`/`set`：访问行为被生成为一个**存取器方法**进行调用。编译器会确保存取器可用。
- `dynamic`：类似 `get`/`set` 访问，但是编译器不会验证存取器字段是否存在。
- `never`：不允许访问

> - **default**: Allows normal ﬁeld access if the ﬁeld has public visibility, otherwise equal to null access.
> - **null**: Allows access only from within the deﬁning class.
> - **get/set**: Access is generated as a call to an accessor method. The compiler ensures that the accessor is available.
> - **dynamic**: Like get/set access, but does not verify the existence of the accessor ﬁeld.
> - **never**: Allows no access at all.

> **定义** 存取器方法：
> 一个类型为 `T` 的字段 `field` 的存取器方法（或简称存取器）即，一个名为 `get_field` 且类型为 `Void -> T` 的 **getter**（用于取），或是一个名为 `set_field` 且类型为 `T -> T` 的 **setter**（用于存）。
>
> [warning] Deﬁnition: Accessor method
> An accessor method (or short accessor) for a ﬁeld named field of type T is a getter named get_field of type Void->T or a setter named set_field of type T->T.

> 花絮：存取器名称
> 在Haxe 2中，任意的标识符允许作为访问标识符，可以使定制的存取器方法名是被认可的。这使得部分实现非常难以处理。特别是，Reflect.getProperty() 和 Reflect.setProterty() 必须假定任何名称可能被使用，需要目标生成器生成元信息和执行查找。我们不允许这些标识符，而使用 get_ 和 set_ 命名约定，大大简化了实现。这是Haxe2 和Haxe 3之间一个阻断式的变更。
>
> [warning] Trivia: Accessor names
> In Haxe 2, arbitrary identiﬁers were allowed as access identiﬁers and would lead to custom accessor method names to be admitted. This made parts of the implementation quite tricky todealwith. In particular,Reflect.getProperty() and Reflect.setProperty() had to assume that any name could have been used, requiring the target generators to generate meta-information and perform lookups. We disallowed these identiﬁers and went for the get_ and set_ naming convention which greatly simpliﬁed implementation. This was one of the breaking changes between Haxe 2 and 3.



# 4.2.1.常见访问标识符组合

以下例子展示了属性字段常用的访问标识符组合：

> The next example shows common access identiﬁer combinations for properties:

```haxe
class Main { 
    // 可从外部可读取，只在 Main 中写入 
    public var ro(default, null):Int; 
    
    // 可从外部写入，只在 Main 中读取 
    public var wo(null, default):Int; 
    
    // 通过 getter 和 setter 访问
    // get_x & set_x 
    public var x(get, set):Int; 
    
    // 通过 getter 读取，不可写入 
    public var y(get, never):Int; 
    
    // 字段 x 的 getter 存取器
    function get_x() return 1; 
    
    // 字段 x 的 setter 存取器
    function set_x(x) return x; 
    
    // 字段 y 的 getter 存取器
    function get_y() return 1; 
    
    function new() { 
        var v = x;
        x = 2; 
        x += 1; 
    }
    
    static public function main() { 
        new Main(); 
    }
} 
```

JavaScript 目标平台的输出可以帮助我们理解 main 函数中的字段访问会如何被编译：

> The JavaScript output helps understand what the ﬁeld access in the main-method is compiled to:

```js
var Main = function() { 
    var v = this.get_x(); 
    this.set_x(2); 
    var _g = this; 
    _g.set_x(_g.get_x() + 1);
}; 
```

如上所述，读取访问会生成一个 `get_x()` 的调用，而写入访问会生成一个 `set_x(2)` 的调用，其中 `2` 会被赋值给 `x` 。`+=` 操作生成的代码初看起来有些奇怪，但是可以通过下面的例子来理解：

> As specified, the read access generates a call to `get_x()`, while the write access generates a call to `set_x(2)` where `2` is the value being assigned to `x`. The way the `+=` is being generated might look a little odd at first, but can easily be justified by the following example:

```haxe
class Main { 
    public var x(get, set):Int; 
    function get_x() return 1; 
    function set_x(x) return x; 
    
    public function new() { } 
    
    static public function main() { 
        new Main().x += 1; 
    }
} 
```

 `main` 函数中对字段 `x` 的访问的表达式情况比较复杂：其中具有潜在的副作用，如本例中 `Main` 的构造函数。因此，编译器不能将 `+=` 操作符生成为 `new Main().x = new Main().x + 1`， 而是需要把复杂表达式存进一个局部变量中：

> What happens here is that the expression part of the field access to `x` in the `main` method is **complex**: It has potential side-effects, such as the construction of `Main` in this case. Thus, the compiler cannot generate the `+=` operation as `new Main().x = new Main().x + 1` and has to cache the complex expression in a local variable:

```haxe
Main.main = function() { 
    var _g = new Main(); 
    _g.set_x(_g.get_x() + 1);
}
```



# 4.2.2.对类型系统的影响

属性的出现有对类型系统的一些影响。最重要的是，有必要理解属性是一个编译时功能，因此需要类型是已知的。如果我们要分配一个类的属性为Dynamic，字段访问不会遵守存取器方法。同样，访问限制不再应用，所有的访问是几乎公开的。

> The presence of properties has several consequences on the type system. Most importantly, it is necessary to understand that properties are a compile-time feature and thus require the types to be known. If we were to assign a class with properties to Dynamic, ﬁeld access would not respect accessor methods. Likewise,access restrictions no longer apply and all access is virtually public.

当使用get 或者set 访问标识符，编译器确保getter 和setter实际上存在。下面的问题不会编译：

> Whenusing get or set accessidentiﬁer,the compiler ensures that the getter and setter actually exists. The following problem does not compile:

```haxe
class Main { 
    // Method get_x required by property x is missing 
    public var x(get, null):Int;
    static public function main() {}
} 
```

方法 get_x 丢失了，但是它不必被定义到属性自己的类定义中，只要一个父类中定义了它：

> The method get_x is missing, but it need not be declared on the class deﬁning the property itself as long as a parent class deﬁnes it:

```haxe
class Base { 
    public function get_x() return 1; 
} 
class Main extends Base { 
    // ok, get_x is declared by parent class 
    public var x(get, null):Int; 
    
    static public function main() {} 
} 
```

dynamic 访问修饰符正常的工作就像get 或者 set，但是不会检查存在与否。

> The dynamic access modiﬁer works exactly like get or set, but does not check for the existence



# 4.2.3.getter和setter的规则

存取器方法的可见性不会影响属性的可得到与否。也就是说，如果一个属性是 public 的而且定义为有一个 getter ，不管如何 那个getter 会自我定义为private。

> Visibility of accessor methods has no effect on the accessibility of its property. That is, if a property is public and deﬁned to have a getter, that getter may me deﬁned as private regardless.

getter 和setter 可以访问它们的数据存储的物理字段。编译器确保这类的字段访问，如果从存取器方法本身做出，不会通过存取器方法，从而避免无限递归：

> Both getter and setter may access their physical ﬁeld for data storage. The compiler ensures that this kind of ﬁeld access does not go through the accessor method if made from within the accessor method itself, thus avoiding inﬁnite recursion:

```haxe
 class Main { 
    public var x(default, set):Int;
    
    function set_x(newX) { 
        return x = newX;
    } 
    
    static public function main() {}
} 
```

然而，编译器只有如果至少一个访问标识符是default或者null的时候假设一个物理字段存在。

> However, the compiler assumes that a physical ﬁeld exists only if at least one of the access identiﬁers is default or null.

**物理字段**

> 定义：物理字段
> 一个字段在如下任何一个情况被认为是物理的：
> 一个变量（第4.1节）
> 一个属性（第4.2节）带有 读取访问或者写入访问标识符为default或者null
> 一个属性带有 :isVar 元数据（第6.9节）
> [warning] Deﬁnition: Physical ﬁeld
> A ﬁeld is considered to be physical if it is either
> [warning] * a variable (4.1)
> [warning] * a property (4.2) with the read-access or write-access identiﬁer being default or null
> [warning] * a property (4.2) with :isVar metadata (6.9)

如果不是这种情况，从一个存取器内部访问字段导致一个编译错误：

> If this is not the case,access to the ﬁeld from within an accessor method causes a compilation error:

```haxe
class Main {
    // This field cannot be accessed because it is not a real variable 
    public var x(get, set):Int; 
    
    function get_x() { 
        return x; 
    } 
    
    function set_x(x) { 
        return this.x = x;
    } 
    
    static public function main() {} 
} 
```

如果一个物理字段是真实准备的，它可以通过归于讨论的字段被强制与 :isVar 元数据。

> If a physical ﬁeld is indeed intended,it can be forced by attributing the ﬁeld in question with the :isVar metadata (6.9):

```haxe
class Main { 
    // @isVar forces the field to be physical allowing the program to compile. 
    @:isVar public var x(get, set):Int; 
    
    function get_x() { 
        return x; 
    }
    
    function set_x(x) { 
        return this.x = x;
    }
    
    static public function main() {} 
}
```

> **花絮**：属性的 setter 类型
> 并不少见新的Haxe用户被setter的类型需要是T->T而不是看起来更自然的T->Void类型惊讶到。毕竟，为什么一个setter需要返回些什么呢？基本原理是，我们仍然想要可以是i用字段分配使用setter为右手表达式。给定一个链如 x=y=1 ，执行为 x=(y=1) 。为了赋值y=1的结果到x，形式必须有一个值。如果 y 有一个setter 返回Void，这是不可能的。
> [warning] Trivia: Property setter type
> It is not uncommon for new Haxe users to be surprised by the type of a setter being required to be T->T instead of the seemingly more natural T->Void. After all, why would a setter have to return something? The rationale is that we still want to be able to use ﬁeld assignments using setters as rightside expressions. Given a chain like x = y = 1, it is evaluated as x = (y = 1). In order to assign the result of y = 1 to x, the former must have a value. If y had a setter returning Void, this would not be possible.