# 4.3.2.变异和访问修饰符的影响

重载遵守变异（第3.4节）的规则。也就是说，它们的参数类型允许逆变（不那么特定的类型）而它们的返回类型允许共变（更特别的类型）。

> Overriding adheres to the rules of variance (3.4). That is, their argument types allow contravariance (less speciﬁc types) while their return type allows covariance (more speciﬁc types):

```haxe
class Base { 
    public function new() { } 
} 

class Child extends Base { 
    private function method(obj:Child):Child {
        return obj; 
    }
} 

class ChildChild extends Child { 
    public override function method(obj:Base):ChildChild { 
        return null; 
    } 
}

class Main { 
    static public function main() { } 
} 
```

直观的说，这是因为参数被“写入”到函数中，而返回值是从函数中“读取”。

> Intuitively, this follows from the fact that arguments are “written to” the function and the return value is “read from” it.

示例也展示了如何改变可见性（第4.4.1节）：一个重载的字段可能是 public ，如果被重载的字段是private，但是相反则不行。

> The example also demonstrates how visibility (4.4.1) may be changed: An overriding ﬁeld may be public if the overridden ﬁeld is private, but not the other way around.

不可能重载声明为内联（第4.4.2节）的字段。这是由于冲突的概念：当内联在编译时通过替换一个函数体的调用，重载字段必须被在运行时决定。

> It is not possible to override ﬁelds which are declared as inline (4.4.2). This is due to the conﬂicting concepts: While inlining is done atcompile-time by replacinga call with thefunction body, overriding ﬁelds necessarily have to be resolved at runtime.