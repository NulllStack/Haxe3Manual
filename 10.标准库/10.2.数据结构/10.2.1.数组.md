# 10.2.1.数组

一个数组是一个元素的集合。它有一个类型参数（第3.2节），对应这些元素的类型。数组可以被通过以下三种方式创建：

- 使用它们的构造函数 ： new Array()
- 使用数组声明语法（第5.5节） ： [1, 2, 3]
- 使用数组推导（第6.6节） ： [for (i in 0...10) if ( i % 2 == 0 ) i]

数组附带一个 API ，覆盖了多数的用例。另外，它们允许读/写 的数组访问（第5.8节）：

```haxe
class Main { 
    static public function main() { 
        var a = [1, 2, 3]; 
        trace(a[1]); // 2 
        a[1] = 1; 
        trace(a[1]); // 1 
    } 
}
```

由于 Haxe 中的数组访问是没有边界的，即，数组保证不会抛出异常，这需要进一步讨论：

- 如果对一个不存在的索引做出一个读访问，将根据目标语言返回一个值。
- 如果对一个越界的正索引做出一个写访问，则在最后有定义的索引与这个新写入的索引项之间的所有位置插入null（或者静态目标语言（第2.2节）中基本类型（第2.1节）的默认值（第2.2节））。
- 如果使用一个负索引写访问，结果是未指定的。

数组在它的元素之上定义了一个迭代器（第6.7节）。这个迭代通常由编译器优化后以一个 while 循环（第5.14节）配合数组下标进行：

```haxe
class Main { 
    static public function main() { 
        var scores = [110, 170, 35];
        var sum = 0; 
        for (score in scores) { 
            sum += score; 
        } 
        trace(sum); // 315
    }
} 
```

Haxe 生成这个优化后的 JavaScript 输出：

```haxe
 Main.main = function() { 
    var scores = [110,170,35]; 
    var sum = 0; 
    var _g = 0; 
    while(_g < scores.length) { 
        var score = scores[_g]; 
        ++_g; 
        sum += score; 
    }
    console.log(sum); 
};
```

Haxe 不允许混合类型的数组，除非参数类型被限强制为 Dynamic（第2.7节）：

```haxe
class Main { 
    static public function main() { 
        // Compile Error: Arrays of mixed types are only allowed if the type is 
        // forced to Array<Dynamic> 
        //var myArray = [10, "Bob", false];
        
        // Array<Dynamic> with mixed types 
        var myExplicitArray:Array<Dynamic> = [10, "Sally", true];
    } 
}
```

> **花絮**: 动态数组
> 在Haxe 2中，混合类型的数组声明是被允许的。在Haxe 3中，数组只有显式声明为 Array 才可以为混合类型。

查看数组API了解它的方法的详细内容。