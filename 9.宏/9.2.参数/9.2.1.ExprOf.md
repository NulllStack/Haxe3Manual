# 9.2.1.ExprOf

由于Expr兼容任何可能的输入，Haxe提供了一个类型 haxe.macro.ExprOf 。大多数情况下，这个类型和Expr完全相同的，但是它允许限制接受的表达式的类型。这在结合宏和静态扩展（第6.3节）时可以提供帮助：

```haxe
import haxe.macro.Expr; 
using Main; 

class Main { 
    static public function main() { 
        identity("foo"); 
        identity(1); 
        "foo".identity(); 
        // Int has no field identity 
        //1.identity(); 
    } 
    
    macro static function identity(e:ExprOf<String>) { 
        return e; 
    } 
} 
```

两个对 identity 的直接调用被接受，即使参数声明为 ExprOf 。这可能有点出乎意料，Int 1 被接受，但是它是关于宏参数（第9.2节）中解释的一个合乎逻辑的结论：参数表达式从不被类型化，所以它不可能让编译器使用合一（第3.5节）检查它们的兼容性。

下两行使用静态扩展（注意 using Main）的则有所不同：对于这些它是强制首先类型化左侧（“foo” 和 1）来理解identity字段访问。这使它可以检查参数类型对应的类型，使 1.identity() 不把 Main.identity() 作为一个适用的字段。