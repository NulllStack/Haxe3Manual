# 9.5.1.枚举构建

构建枚举类似于使用一个简单的映射构建类：

- 没有参数的枚举构造函数是变量字段 FVar。
- 带有参数的枚举构造函数是方法字段 FFun 。

```haxe
import haxe.macro.Context;
import haxe.macro.Expr;

class EnumBuildingMacro {
  macro static public function build():Array<Field> {
    var noArgs = makeEnumField("A", FVar(null, null));
    var eFunc = macro function(value:Int) { };
    var fInt = switch (eFunc.expr) {
      case EFunction(_,f): f;
      case _: throw "false";
    }
    var intArg = makeEnumField("B", FFun(fInt));
    return [noArgs, intArg];
  }

  static function makeEnumField(name, kind) {
    return {
      name: name,
      doc: null,
      meta: [],
      access: [],
      kind: kind,
      pos: Context.currentPos()
    }
  }
}
@:build(EnumBuildingMacro.build())
enum E { }

class Main {
  static public function main() {
    switch(E.A) {
      case A:
      case B(v):
    }
  }
}
```

因为枚举 E 被使用一个 :build 元数据注解，调用的宏构建两个构造函数 A 和 B 到它之中。前者被添加使用的类型是 FVar(null, null)，意味着它是一个构造函数，没有参数。后者，我们使用具体化来获得 haxe.macro.Expr.Function 的一个实例，参数为一个单独的 Int 。

main 方法通过匹配它，证明了我们生成的枚举的结构。我们可以发现，生成的类型跟下面这个是等价的：

```haxe
enum E {
  A;
  B(value:Int);
}
```