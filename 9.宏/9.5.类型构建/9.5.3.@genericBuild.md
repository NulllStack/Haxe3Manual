# 9.5.3.@:genericBuild

**从Haxe 3.1.0 后：**
一般构建宏每个类型化运行，已经非常强大。在一些情况下，每个类型化运行一个构建宏相反用法，即，当它实际上出现在代码中。除此之外这允许在宏中访问具体的类型参数。

@:genericBuild 就像 @:build 一样使用，通过添加它到一个类型，并使用一个宏调用作为参数：

```haxe
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Type;

class GenericBuildMacro1 {
  static public function build() {
    switch (Context.getLocalType()) {
      case TInst(_, [t1]):
        trace(t1);
      case t:
        Context.error("Class expected", Context.currentPos());
    }
    return null;
  }
}

@:genericBuild(GenericBuildMacro1.build())
class MyType<T> { }

class Main {
  static function main() {
    var x:MyType<Int>;
    var x:MyType<String>;
  }
}
```

当运行这个例子，编译器输出 TAbstract(Int,[]) 和 TInst(String,[])，表明它确实意识到 MyType的具体类型参数。宏的逻辑可以使用这个信息来生成一个定制类型（使用 haxe.macro.Context.defineType）或者引用一个存在的类型。方便起见，我们在这里返回null，要求编译器推断这个类型。

在Haxe 3.1 中，一个 @:genericBuild 宏的返回类型必须是一个 haxe.macro.Type 。Haxe 3.2 允许（也更愿意）返回一个 haxe.macro.ComplexType ，是一个类型语法上的表示。在很多情况下这变得很容易使用，因为类型可以通过它们的路径简单的引用。

**Const 类型参数**
如果类型参数名称是 Const，Haxe 允许传递常量表达式（第5.2节）作为一个类型参数。这可以在 @:genericBuild 宏的上下文中被利用来从语法直接到宏传递信息：

```haxe
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Type;

class GenericBuildMacro2 {
  static public function build() {
    switch (Context.getLocalType()) {
      case TInst(_,[TInst(_.get() => { kind: KExpr(macro $v{(s:String)}) },_)]):
        trace(s);
      case t:
        Context.error("Class expected", Context.currentPos());
    }
    return null;
  }
}
@:genericBuild(GenericBuildMacro2.build())
class MyType<Const> { }

class Main {
  static function main() {
    var x:MyType<"myfile.txt">;
  }
}
```

这里宏的逻辑可以加载一个文件并使用它的内容来生成一个定制类型。