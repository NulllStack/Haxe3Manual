# 2.8.3.数组访问

数组访问描述了特定的语法，传统上用于访问数组中的某个偏移量的值。通常只允许带有 Int 类型的参数。然而，使用抽象类型也可以定义自己的数组访问方法。[Haxe 标准库（第10章）](http:///#) 通过它的 Map 类型应用这种方式，其中下面两个方法可以被发现：

```haxe
@:arrayAccess 
public inline function get(key:K) {
    return this.get(key); 
}

@:arrayAccess 
public inline function arrayWrite(k:K, v:V):V { 
    this.set(k, v); 
    return v; 
} 
```

有两种数组访问方法：

- 如果一个 `@:arrayAccess` 方法接受一个参数，它是一个 `getter`；
- 如果一个 `@:arrayAccess` 方法接受两个参数，它是一个 `setter`。

然后下面看到的 `get` 和 `arrayWrite` 方法允许这样使用：

```haxe
class Main { 
    public static function main() { 
        var map = new Map(); 
        map["foo"] = 1; 
        trace(map["foo"]); 
    }
} 
```

在这一点上，看到数组访问字段的调用被插入到输入内容应该不会太让人吃惊：

```haxe
 map.set("foo",1); 
 console.log(map.get("foo")); // 1
```

**数组访问解析的顺序**
 由于Haxe 3.2 版本之前的一个 bug，检查 `:arrayAccess` 字段的顺序是未被定义的。在 3.2 版本中已经修复所以现在总是从上到下进行检查字段：

```haxe
abstract AString(String) { 
    public function new(s) this = s;
    @:arrayAccess function getInt1(k:Int) {
        return this.charAt(k); 
    } 
    @:arrayAccess function getInt2(k:Int) { 
        return this.charAt(k).toUpperCase();
    }
}

class Main { 
    static function main() {
        var a = new AString("foo"); 
        trace(a[0]); // f 
    }
} 
```

数组访问 `a[0]` 被解析到 `getInt1` 字段，使得小写的 `f` 被返回。结果可能和 Haxe 3.2 之前的版本不同。

先定义的字段有优先级，即使它们需要一个[ 隐式的转换（第2.8.1节）](http:///#)。

