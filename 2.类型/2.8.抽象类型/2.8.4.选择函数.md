# 2.8.4.选择函数

由于编译器提升抽象成员函数为静态函数，可以手动定义静态函数并使用它们到一个抽象类的实例。这里的语法和那些第一个函数参数类型决定函数被定义为什么类型的 [静态扩展（第6.3节）](http:///#) 类似，：

```haxe
abstract MyAbstract<T>(T) from T {
    public function new(t:T) this = t; 
    
    function get() return this;
    @:impl 
    static public function getString(v:MyAbstract<String>):String { 
        return v.get(); 
    }
} 

class Main { 
    static public function main() { 
        var a = new MyAbstract("foo");
        a.getString(); 
        var b = new MyAbstract(1); 
        // Int should be MyAbstract<String> 
        b.getString();
    }
} 
```

抽象类型 `MyAbstract` 的方法 `getString` 被定义为接受一个 `MyAbstract` 类型首参数。这使它在第14行可以用在变量 `a` 上（因为 `a` 的类型为 `MyAbstract`），但是不能用在变量 `b` 上，`b` 的类型是 `MyAbstract` 。

> **花絮**：意外的功能
>  选择函数是被发现的，而不是真的设计了它的用法。在第一次提到这个想法后，只需要编译器中的一点调整就可以使它们工作。它们的这些发现还引入了多类型抽象类型，比如 Map 。