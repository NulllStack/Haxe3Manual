# 2.3.类实例

和许多面向对象语言类似，类是大多数 Haxe 程序中主要的数据结构。每个 Haxe 类都有一个确定的名字，一个隐含的路径和零或者多个类字段。这里我们将关注类的一般结构和它们的关系，而 [类字段（第4章）](http:///#) 的细节部分在后面进行讲解。

如下代码示例作为本节剩余部分的基础：

```haxe
class Point { 
    var x : Int; 
    var y : Int;
    public function new(x,y) { 
        this.x = x;
        this.y = y; 
    }
    public function toString() { 
        return "Point("+x+","+y+")";
    }
} 
```

从语义上讲，这个类表示二维空间内的一个点，但是这里它是什么并不重要。我们来描述一下这个结构：

- 关键字 `class` 表示我们定义一个类
- `Point` 是类的名称，可以使用任何符合类型标识符规则的字符
- 包围在花括号 `{}` 中间的是类的字段
- 它由两个 Int 类型变量字段 `x` 和 `y` 组成
- 后面是一个特定的函数字段叫做 `new` ，它是类的构造函数
- 还有一个普通的函数 `toString`

在 Haxe 中有一个特殊类型，可以兼容所有的类：

> **类型** ：Class
>  这个类型可以兼容所有类型，也就是说，所有类（而不是它们的实例）可以被分配给它。在编译时，`Class` 是所有类的基础类型。然而，这个关系并不会反映在生成的代码中。当一个 API 需要的一个值是一个类而非某个特定的类型时，可以使用这个类型。这应用到 [Haxe 反射API （第10.7节）](http:///#) 中的一些方法。



# 2.3.1.类的构造函数

类的实例通过调用类的构造函数（一个通常称为实例化的过程）创建。类实例的另一个称呼叫做对象。然而，我们更倾向于使用术语“类的实例”来强调 类/类实例和 枚举/[枚举实例（第2.4节](http:///#)）之间的类比。

```haxe
var p = new Point(-1, 65);
```

这会生成一个 `Point` 类的实例，它被分配到一个变量 `p` 上。`Point` 的构造函数接受两个参数 `-1` 和 `65`，然后分别分配它们到实例变量 `x` 和 `y`（对比在 [类实例（第2.3节）](http:///#) 中它的定义）。我们将在 [new（第5.12节） ](http:///#) 中重新审视 new 表达式的精确意思。现在，只要把它当作调用类的构造函数并返回适当的对象。



# 2.3.2.继承

类可以继承自其它的类，在 Haxe 中通过 extends 关键字指示：

```haxe
class Point3 extends Point {
    var z : Int;
    public function new(x,y,z) {
        super(x,y);
        this.z = z; 
    } 
}
```

这个关系通常被称为 “is-a”（subsumption，包含架构，指的是类的父子继承关系）：任何 `Point3` 类的实例同时也是 `Point` 类的实例。`Point` 则作为 `Point3` 的父类，而 `Point3` 则是 `Point` 的子类。一个类可以有许多子类，但是只有一个父类。术语“一个 class X 的父类”通常指它的直接父类、父类的父类等。

上面的代码和原来的 `Point` 类很相似，使用了两个新的部分：

`extends Point` 表示这个类继承自 `Point` 类。
`super(x, y)` 是调用父类的构造函数，本例中即 `Point.new` 。

在子类中定义它们自己的构造函数并不是必须的，但是如果定义了，则调用 super() 是强制性的。这不像其它一些面向对象语言，这个调用可以出现在构造函数代码中的任何地方，而不是必须作为第一个表达式。

一个类可以重写它父类的 [方法（第4.3节）](http:///#)，需要显式的 override 关键字。效果和限制将在 [重写方法（第4.3.1节）](http:///#) 中详细介绍。



# 2.3.3.接口

一个接口可以被理解为类的签名，因为它描述了类的公共字段。接口不提供实现，而是纯粹的结构上的信息：

```haxe
interface Printable {
    public function toString():String;
} 
```

语法和类的相似，但有以下例外：

- 使用 `interface` 关键字而不是 `class` 关键字
- 函数不需要任何表达式
- 每个字段必须有一个显式的类型

接口，它不像 [结构子类型化（第3.5.2节）](http:///#)，它描述和类之间一个静态的关系。一个指定的类，如果被显式地陈述如下，则只被认为是兼容一个接口：

```haxe
class Point implements Printable { }
```

这里，`implements` 关键字表示 `Point` 类有一个到 `Printable` 接口的“is-a”关系，即每个 `Point` 的实例同时也是 `Printable` 接口的实例。虽然一个类只能有一个父类，但是它可以通过使用多个 `implements` 关键字实现多个接口：

```haxe
class Point implements Printable 
    implements Serializable 
```

编译器检查是否实现了假设。也就是说，它确保类实际上实现了接口必须的所有字段。一个字段，如果类或者任何它的父类提供了一个实现，那么它被认为是实现了。接口字段不限于方法。也可以是变量或者属性：

```haxe
interface Placeable { 
    public var x:Float; 
    public var y:Float; 
}

class Main implements Placeable {
    public var x:Float;
    public var y:Float; 
    static public function main() { }
} 
```

接口可以扩展多个其它的接口，使用 `extends` 关键字：

```haxe
interface Debuggable extends Printable extends Serializable
```

> **花絮**：实现的语法
> Haxe 3.0 之前 需要多个 `implements` 关键字，使用逗号 `,` 隔开。我们决定遵循 Java 事实上的标准，免除了逗号。这个是 Haxe 2 和 Haxe 3 之间的一个致命变更。