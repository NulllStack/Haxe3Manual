# 2.4.枚举实例

Haxe 提供了强大的枚举类型（简写：enum），它实际上是一个代数数据类型（ADT）。虽然它们不能有任何表达式，但用来描述数据结构是非常实用的：

```haxe
enum Color {
    Red;    
    Green;
    Blue;
    Rgb(r:Int, g:Int, b:Int);
} 
```

从语义上看，这个 enum 描述了一个颜色，可能是红色，绿色，蓝色或者一个特定的 RGB 值。它的语法构成如下：

- 关键字 `enum` 表示我们要声明一个枚举
- `Color` 是枚举类型的名称，可以是任何符合类型标识符规则的字符
- 闭合的花括号中间是枚举的构造函数
- `Red`，`Green` 和 `Blue` 不需要参数
- 而 `Rgb` 需要三个 Int 类型的参数，分别是 `r`，`g` 和 `b`

Haxe 类型系统提供一个和所有的枚举类型统一的类型：

## Enum

> **类型**：Enum
>  这个类型可以兼容所有的枚举类型。在编译时，`Enum` 可以被看作枚举类型的通用基本类型。然而，这个关系不会反应在生成的代码中。



# 2.4.1.Enum构造函数

类似于类和它们的构造函数，枚举通过使用它们的一个构造函数提供了一种实例化方式。然而，与类不同，枚举提供了多个可以简单的通过它们的名字使用的构造函数：

```haxe
var a = Red;
var b = Green; 
var c = Rgb(255, 255, 0)
```

在这段代码中变量 `a`，`b` 和 `c` 的类型为 `Color`。变量 `c` 使用 `Rgb` 构造函数和参数来初始化。

所有枚举实例都可以被分配到一个名为 `EnumValue` 的特定类型 。

## EnumValue

> **类型**：EnumValue
> `EnumValue` 是一个特别的类型，统一所有的枚举实例。它被 Haxe 标准库使用，来提供对所有枚举实例的某些操作，可以用在用户代码中一个 需要一个枚举实例而不是某个特定的类型的 API 的情况。

重要的是区分枚举类型和枚举构造函数，如这个示例展示的：

```haxe
enum Color
{
    Red;
    Green;
    Blue;
    Rgb(r:Int,g:Int,b:Int);
}

class Main{
    public static function main(){
        var ec:EnumValue = Red; //有效
        var en:Enum<Color> = Color; //有效
            
        // error, Color 应该是 Enum<Color>
        // var x :Enum<Color> = Red;
    }
}
```

如果上面注释掉的行没有被注释，程序不会通过编译，因为 `Red` （一个枚举构造函数）不能被赋值到一个 `Enum` （一个枚举类型）类型的变量。这个关系就像类和类的实例。

## Enum

> **花絮**：Enum的具体类型参数
> 手册的一个读者困惑于上面示例中 `Color` 和 `Enum` 的区别。事实上，这里使用一个具体类型参数是没有意义的，只是用于演示目的。通常我们会在这里省略类型，让 [类型推断（第3.6节）](http:///#) 来处理它。然而，推断的类型可能和 `Enum` 不同。编译器推断出一个将枚举的构造函数 作为“字段”的伪类型。自 Haxe3.2.0 起，就不能在语法中表达这个类型，而且也没有必要这么做。



# 2.4.2.使用枚举

如果只有一组有限的值被允许使用，那么枚举类型是一个不错的选择。个体的 [构造函数（第2.4.1节）](http:///#) 表示允许的变型，并使编译器检查是否所有可能的值都被遵守的。可以在这里看到：

```haxe
enum Color{
    Red;
    Green;
    Blue;
    Rgb(r:Int, g:Int, b:Int);
}
class Main{
    public static function main(){
        var color = getColor();
        switch(color){
            case Red:
                trace("color was red");
            case Green:
                trace("color was green");
            case Blue:
                trace("color was blue");
            case Rgb(r,g,b):
                trace("color had a red value of " + r);
        }
    }
    
    static function getColor():Color{
        return Rgb(255, 0, 255);
    }
}
```

在检索通过分配`getColor()` 的返回值分配给 `color` 的值之后，一个 [switch 语句（第5.17节）](http:///#) 根据 `color` 值进行分支。前三个情况是 `Red`，`Green` 和 `Blue`，它们是没有价值的，但是跟 `Color` 中没有参数的构造函数一致。最后的 `Rgb(r,g,b)` 展示如何提取构造函数中的参数值：它们可以作为局部变量使用在 `case` 表达式主体中，就像使用了一个 [var 表达式（第5.10节）](http:///#) 一样。关于使用 `switch` 语句的高级信息将在 [模式匹配（第6.4节）](http:///#) 章节进一步探索。