# 5.23.1.不安全转换

Unsafe casts are useful to subvert the type system. The compiler types expr as usual and then wraps it in a monomorph (2.9). This allows the expression to be assigned to anything.
 不安全的类型转换不使用任何 dynamic（第2.7节）类型，如下面例子展示的：

> Unsafe casts do not introduce any dynamic (2.7) types, as the following example shows:

```haxe
class Main { 
    public static function main() { 
        var i = 1; 
        $type(i); // Int 
        var s = cast i; 
        $type(s); // Unknown<0> 
        Std.parseInt(s); 
        $type(s); // String 
    } 
} 
```

变量 i 类型化为 Int，然后经过不安全转换 cast i 之后赋值到变量。这使 s 成为一个 unknown 类型，一个单形。根据合一（第3.5节）的一般规则，它可以之后被绑定为任何类型，例如例子中的 String 。

> Variable i is typed as Int and then assigned to variables using the unsafe cast cast i. This causes s to be of an unknown type,amonomorph. Following the usual rules of uniﬁcation(3.5), it can then be bound to any type, such as String in this example.

这些转换被称为不安全的，因为无效转换的运行时行为没有被定义。而多数 动态目标语言（第2.2节）可能可以工作，但是在静态目标语言（第2.2节）可能导致未定义的错误。

> These casts are called ”unsafe” because the runtime behavior for invalid casts is not deﬁned. While most dynamic targets (2.2) are likely to work, it might lead to undeﬁned errors on static targets (2.2).

不安全转换几乎没有运行时的开销。

> Unsafe casts have little to no runtime overhead.