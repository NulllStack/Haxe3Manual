# 5.11.局部函数

Haxe 支持表达式中使用 类级 函数声明也支持 局部 函数声明。其语法遵循类字段方法（4.3）的语法：

Haxe supports ﬁrst-class functions and allows declaring local functions in expressions. The syntax follows class ﬁeld methods (4.3):

```haxe
class Main { 
    static public function main() { 
        var value = 1; 
        function myLocalFunction(i) { 
            return value + i; 
        } 
        trace(myLocalFunction(2)); // 3 
    } 
} 
```

我们声明了一个 `myLocalFunction` 位于类字段 `main` 的块表达式（5.1）中。它接受一个参数，并对参数加上外部作用域中定义的 `value` 的值。

We declare myLocalFunction inside the block expression (5.1) of the main class ﬁeld. It takes one argument i and adds it to value, which is deﬁned in the outside scope.

其作用域等同于 变量（5.10）的作用域，且大多数情况下声明一个带命名的局部函数实际上可以被看作是把一个匿名函数赋值到一个变量上：

The scoping is equivalent to that of variables (5.10) and for the most part writing a named local function can be considered equal to assigning an unnamed local function to a local variable:

```haxe
var myLocalFunction = function(a) { } 
```

但是当涉及类型参数（3.2）以及函数所处位置时有些不同。当一个函数声明的位置没有将其赋值给任何东西时，我们称它为 'lvalue' 函数，反之称其为 'rvalue' 函数。

- lvalue 函数**必须有**一个名字，且可以具有类型参数（3.2）
- rvalue 函数**不一定**有名字，但不可以具有类型参数

However, there are some differences related to type parameters and the position of the function. We speak of a “lvalue” function if it is not assigned to anything upon its declaration, and an “rvalue” function otherwise.

- Lvalue functions require a name and can have type parameters (3.2).
- Rvalue functions may have a name, but cannot have type parameters.



个人补充：

```haxe
var function(){}; //这是一个 lvalue 函数,不过匿名的 lvalue 函数声明编译器是不给通过的
var function gotNamed(){}; //这是一个合法的 lvalue 函数声明
var fun = function(){}; //匿名函数被声明并赋值给变量 fun, 此时匿名函数可以看作是 rvalue，但是 fun 本身是 lvalue 函数
var funfunfun = function hasName(){}; //同上 hasName 是 rvalue 函数，funfunfun 是 lvalue 函数

// 假设此时有一个函数 loadSomething() 它接受一个带类型参数的函数类型作为参数
// 以下调用编译器会报错：
loadSomething(
    function<T>(x:T)
    {
        // do something
    }
);

// 这是由于匿名函数声明的同时被赋值给了 loadSomething() 的参数，即匿名函数是一个 rvalue 函数，但是 rvalue 函数不允许使用类型参数
// 此时我们需要这么做：
function lvalueFun<T>(x:T)
{
    // do something
};
loadSomething(lvalueFun);
```

