# 5.3.2 二元操作符



##### [Arithmetic operators](#arithmetic-operators)

| Operator | Operation      | Operand 1   | Operand 2   | Result type |
| -------- | -------------- | ----------- | ----------- | ----------- |
| `%`      | modulo         | `Float/Int` | `Float/Int` | `Float/Int` |
| `*`      | multiplication | `Float/Int` | `Float/Int` | `Float/Int` |
| `/`      | division       | `Float/Int` | `Float/Int` | `Float`     |
| `+`      | addition       | `Float/Int` | `Float/Int` | `Float/Int` |
| `-`      | subtraction    | `Float/Int` | `Float/Int` | `Float/Int` |

About the `Float/Int` return type: If one of the operands is of type `Float`, the resulting expression will also be of type `Float`, otherwise the type will be `Int`. The result of a division is always a `Float`; use `Std.int(a / b)` for integer division (discarding any fractional part).

In Haxe, the result of a modulo operation always keeps the sign of the dividend (the left operand) if the divisor is non-negative. The result is target-specific with a negative divisor.



##### [String concatenation operator](#string-concatenation-operator)

| Operator | Operation     | Operand 1 | Operand 2 | Result type |
| -------- | ------------- | --------- | --------- | ----------- |
| `+`      | concatenation | any       | `String`  | `String`    |
| `+`      | concatenation | `String`  | any       | `String`    |
| `+=`     | concatenation | `String`  | any       | `String`    |

Note that the "any" operand will be stringified. For classes and abstracts stringification can be controlled with user-defined `toString` function.



##### [Bitwise operators](#bitwise-operators)

| Operator | Operation            | Operand 1 | Operand 2 | Result type |
| -------- | -------------------- | --------- | --------- | ----------- |
| `<<`     | shift left           | `Int`     | `Int`     | `Int`       |
| `>>`     | shift right          | `Int`     | `Int`     | `Int`       |
| `>>>`    | unsigned shift right | `Int`     | `Int`     | `Int`       |
| `&`      | bitwise and          | `Int`     | `Int`     | `Int`       |
| `|`      | bitwise or           | `Int`     | `Int`     | `Int`       |
| `^`      | bitwise xor          | `Int`     | `Int`     | `Int`       |



##### [Logical operators](#logical-operators)

| Operator | Operation   | Operand 1 | Operand 2 | Result type |
| -------- | ----------- | --------- | --------- | ----------- |
| `&&`     | logical and | `Bool`    | `Bool`    | `Bool`      |
| `||`     | logical or  | `Bool`    | `Bool`    | `Bool`      |

**Short-circuiting:**

Haxe guarantees that compound boolean expressions with the same operator are evaluated from left to right but only as far as necessary at run-time. For instance, an expression like `A && B` will evaluate `A` first and evaluate `B` only if the evaluation of `A` yielded `true`. Likewise, the expression `A || B` will not evaluate `B` if the evaluation of `A` yielded `true`, because the value of `B` is irrelevant in that case. This is important in cases such as this:

```haxe
if (object != null && object.field == 1) { }
```

Accessing `object.field` if `object` is `null` would lead to a run-time error, but the check for `object != null` guards against it.



##### [Compound assignment operators](#compound-assignment-operators)

| Operator | Operation            | Operand 1   | Operand 2   | Result type |
| -------- | -------------------- | ----------- | ----------- | ----------- |
| `%=`     | modulo               | `Float/Int` | `Float/Int` | `Float/Int` |
| `*=`     | multiplication       | `Float/Int` | `Float/Int` | `Float/Int` |
| `/=`     | division             | `Float`     | `Float/Int` | `Float`     |
| `+=`     | addition             | `Float/Int` | `Float/Int` | `Float/Int` |
| `-=`     | subtraction          | `Float/Int` | `Float/Int` | `Float/Int` |
| `<<=`    | shift left           | `Int`       | `Int`       | `Int`       |
| `>>=`    | shift right          | `Int`       | `Int`       | `Int`       |
| `>>>=`   | unsigned shift right | `Int`       | `Int`       | `Int`       |
| `&=`     | bitwise and          | `Int`       | `Int`       | `Int`       |
| `|=`     | bitwise or           | `Int`       | `Int`       | `Int`       |
| `^=`     | bitwise xor          | `Int`       | `Int`       | `Int`       |

In all cases, a compound assignment modifies the given variable, field, structure member, etc., so it will not work on a read-only value. The compound assignment evaluates to the modified value when used as a sub-expression:

```haxe
var a = 3;
trace(a += 3); // 6
trace(a); // 6
```

Note that the first operand of `/=` must always be a `Float`, since the result of a division is always a `Float` in Haxe. Similarly, `+=` and `-=` cannot accept `Int` as the first operand if `Float` is given as the second operand, since the result would be a `Float`.



##### [Numeric comparison operators](#numeric-comparison-operators)

| Operator | Operation             | Operand 1   | Operand 2   | Result type |
| -------- | --------------------- | ----------- | ----------- | ----------- |
| `==`     | equal                 | `Float/Int` | `Float/Int` | `Bool`      |
| `!=`     | not equal             | `Float/Int` | `Float/Int` | `Bool`      |
| `<`      | less than             | `Float/Int` | `Float/Int` | `Bool`      |
| `<=`     | less than or equal    | `Float/Int` | `Float/Int` | `Bool`      |
| `>`      | greater than          | `Float/Int` | `Float/Int` | `Bool`      |
| `>=`     | greater than or equal | `Float/Int` | `Float/Int` | `Bool`      |



##### [String comparison operators](#string-comparison-operators)

| Operator | Operation                         | Operand 1 | Operand 2 | Result type |
| -------- | --------------------------------- | --------- | --------- | ----------- |
| `==`     | equal                             | `String`  | `String`  | `Bool`      |
| `!=`     | not equal                         | `String`  | `String`  | `Bool`      |
| `<`      | lexicographically before          | `String`  | `String`  | `Bool`      |
| `<=`     | lexicographically before or equal | `String`  | `String`  | `Bool`      |
| `>`      | lexicographically after           | `String`  | `String`  | `Bool`      |
| `>=`     | lexicographically after or equal  | `String`  | `String`  | `Bool`      |

Two values of type `String` are considered equal in Haxe when they have the same length and the same contents:

```haxe
var a = "foo";
var b = "bar";
var c = "foo";
trace(a == b); // false
trace(a == c); // true
trace(a == "foo"); // true
```



##### [Equality operators](#equality-operators)

| Operator | Operation | Operand 1 | Operand 2 | Result type |
| -------- | --------- | --------- | --------- | ----------- |
| `==`     | equal     | any       | any       | `Bool`      |
| `!=`     | not equal | any       | any       | `Bool`      |

The types of operand 1 and operand 2 must [unify]().

**Enums:**

- Enums without parameters always represent the same value, so `MyEnum.A == MyEnum.A`. 
- Enums with parameters can be compared with `a.equals(b)` (which is short for `Type.enumEquals()`).

**Dynamic:**

Comparison involving at least one operand of type `Dynamic` is unspecified and platform-specific.



##### [Miscellaneous operators](#miscellaneous-operators)

| Operator | Operation                                                    | Operand 1 | Operand 2 | Result type   |
| -------- | ------------------------------------------------------------ | --------- | --------- | ------------- |
| `...`    | interval (see [range iteration]())                           | `Int`     | `Int`     | `IntIterator` |
| `=>`     | arrow (see [map](), [key-value iteration](), [map comprehension]()) | any       | any       | -             |