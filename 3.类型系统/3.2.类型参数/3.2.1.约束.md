# 3.2.1.约束

类型参数可以通过多种类型被约束：

> Type parameters can be constrained to multiple types:

```haxe
typedef Measurable = {
  public var length(default, null):Int;
}

class Main {
  static public function main() {
    trace(test([]));
    trace(test(["bar", "foo"]));
    // String should be Iterable<String>
    // test("foo");
  }

  #if (haxe_ver >= 4)
  static function test<T:Iterable<String> & Measurable>(a:T) {
  #else
  static function test<T:(Iterable<String>, Measurable)>(a:T) {
  #end
    if (a.length == 0)
      return "empty";
    return a.iterator().next();
  }
}
```

方法 `test` 的类型参数 `T` 被约束为 `Iterable<String>` 和 `Measurable` 。后者为方便起见使用了 typedef（第3.1节）关键字定义且需要兼容有一个`Int` 类型 名为 `length` 的只读属性（第4.2节）。约束指明一个兼容的类型满足：

> The `test` method contains a type parameter `T` that is constrained to the types `Iterable<String>` and `Measurable`. The latter is defined using a **typedef (3.1)** for convenience and requires compatible types to have a read-only **property (4.2)** named `length` of type `Int`. The constraints then indicate that a type is compatible if:

- 与 `Iterable<String>` 兼容
- 并具有一个 `Int` 类型且名为 `length` 的属性

> - it is compatible with `Iterable<String>` and
> - has a `length` property of type `Int`.

我们可以看到，在第7行调用 `test` 并传递一个空数组，以及第8行传递 `Array<String>` 是没有问题的。因为数组具有 `length` 属性以及 `iterable` 方法。然而，传递一个字符串作为参数，如第9行则会导致约束失败，因为字符串不兼容 `Iterable<T>`。

> In the above example, we can see that invoking `test` with an empty array on line 7 and an `Array<String>` on line 8 works fine. This is because `Array` has both a `length` property and an `iterator` method. However, passing a `String` as argument on line 9 fails the constraint check because `String` is not compatible with `Iterable<T>`.