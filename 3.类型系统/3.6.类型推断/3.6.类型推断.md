# 3.6.类型推断

类型推断的效果将会频繁出现于整个文档中。一个例子可以展示类型推断：

*The effects of type inference have been seen throughout this document and will continue to be important. A simple example shows type inference at work:*

```haxe
class Main { 
    public static function main() { 
        var x = null; 
        $type(x); // Unknown<0> 
        x = "foo"; 
        $type(x); // String 
    }
} 
```

这里有个特殊的 `$type` 结构在之前为了便于 函数类型（2.6） 的说明稍有提及，现在让我们来正式地介绍它：

*The special construct $type was previously mentioned in order to simplify the explanation of the Function Type (Section 2.6) type, so let us now introduce it ofﬁcially:*

> 定义：$type
>  $type 是一个可以像函数一样调用的编译时机制，它接受一个参数。编译器执行参数的表达式并输出表达式的类型。
>  [warning] Construct: $type
>  *$type is a compile-time mechanism being called like a function,with a single argument. The compiler evaluates the argument expression and then outputs the type of that expression.*

在上面的例子中，第一个 `$type` 输出 `Unknow<0>` 。这是一个 单形（第2.9节），一个还不知道其类型的类型。下一行 `x = "foo"` 将一个 `String` 类型的字面值赋值到变量 `x` 上，于是触发了这个单形与 `String` 之间的一致性检查 。然后我们可以看到 `x` 的类型被改变为 `String` 类型了 。

*In the example above, the first `$type` prints `Unknown<0>`. This is a [monomorph](https://haxe.org/manual/types-monomorph.html), a type that is not yet known. The next line `x = "foo"` assigns a `String` literal to `x`, which causes the [unification](https://haxe.org/manual/type-system-unification.html) of the monomorph with `String`. We then see that the type of `x` has changed to `String`.*

每当一个不同于 Dynamic（第2.7节）的类型被统一为一个单形时，这个单形便会变形（morph）为该类型，并且在此之后它就不能再变形为另外的类型了。这一特性正如其名字中的 mono（单一的）所表达的一样。

*Whenever a type other than [Dynamic](https://haxe.org/manual/types-dynamic.html) is unified with a monomorph, that monomorph **morphs** into that type, or in simpler terms, **becomes** that type. Therefore, it cannot morph into a different type afterwards, a property expressed in the **mono** part of its name.*

遵循一致性检查的规则，类型推断可以在复合类型中触发：

*Following the rules of uniﬁcation, type inference can occur in compound types:*

```haxe
class Main {
    public static function main() { 
        var x = []; 
        $type(x); // Array<Unknown<0>>
        x.push("foo"); 
        $type(x); // Array<String> 
    } 
}
```

变量 `x` 在一开始被初始化为一个空的 `Array` 数组。此时我们除了知道变量 `x` 是一个数组外并不知道其数组元素的具体类型。此时 `x` 的类型必然为 `Array<Unknown<0>>` 。只有当我们为其推入一个 `Sring` 类型元素之后才知道其类型为 `Array<String>`。

*Variable `x` is first initialized to an empty `Array`. At this point, we can tell that the type of `x` is an array, but we do not yet know the type of the array elements. Consequently, the type of `x` is `Array<Unknown<0>>`. It is only after pushing a `String` onto the array that we know the type to be `Array<String>`.*

