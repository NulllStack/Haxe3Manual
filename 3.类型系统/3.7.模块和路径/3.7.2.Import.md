# 3.7.2.Import

如果一个类型路径在一个 .hx 文件中会多次用到，可以使用 import 导入来缩短它。这可以使我们省略包名来使用类型：

> If a type path is used multiple times in a .hx ﬁle,it might make sense to use an import to shorten it. This allows omitting the package when using the type:

```haxe
import haxe.ds.StringMap; 

class Main {    
    static public function main() {
        // instead of: new haxe.ds.StringMap(); 
        new StringMap(); 
    }
} 
```

随着haxe.ds.StringMap被导入之后，编译器就可以通过这个包解析 main 函数中不合法的标识符 StringMap。模块 StringMap 被告知需要被导入到当前的文件 。

> With haxe.ds.StringMap being imported in the ﬁrst line,the compiler is able to resolve the unqualiﬁed identiﬁer StringMap in the main function to this package. The module StringMap is said to be imported into the current ﬁle.

在这个例子中，我们实际上导入了一个模块，而不只是模块中的一个类型。这意味着所有在被导入的模块中定义的类型都是可用的。

> In this example, we are actually importing a module, not just a speciﬁc type within that module. This means that all types deﬁned within the imported module are available:

```haxe
import haxe.macro.Expr; 

class Main { 
    static public function main() {
        var e:Binop = OpAdd; 
    }
}
```

类型 Binop 是haxe.macro.Expr模块中一个 enum（第2.4节）声明，因此在这个模块被导入之后就可以使用了。如果我们只要导入模块中的一个特定类型，例如，import  haxe.macro.Expr.ExprDef，程序会编译失败，提示Binop类没有找到。

> The type Binop is an enum (2.4) declared in the module haxe.macro.Expr,and thus available after the import of said module. If we were to import only a speciﬁc type of that module, e.g. import haxe.macro.Expr.ExprDef, the program would fail to compile with Class not found : Binop.

关于导入有几个方面需要了解：

> There are several aspects worth knowing about importing:

- 最底部的导入指令具有最高的优先级（详见 解析顺序（第3.7.3节））。
- 静态扩展（第6.3节）关键字 using 具有 import 的效果。
- 如果一个enum被导入（直接或作为模块的一部分被导入），所有它的enum构造函数（第2.4.1节）同样也被导入（这就是为什么在上面例子中允许 opAdd 的用法）。

> - The bottommost import takes priority (detailed in Resolution Order (Section 3.7.3)).
> - The static extension (6.3) keyword using implies the effect of import.
> - If an enum is imported (directly or as part of a module import), all its enum constructors (2.4.1) are also imported (this is what allows the OpAdd usage in the above example).

此外，也可以导入类的静态字段并不受限制的使用它们。

> Furthermore, it is also possible to import static ﬁelds (4) of a class and use them unqualiﬁed:

```haxe
import Math.random; 

class Main { 
    static public function main() {
        random(); 
    }
}
```

必须特别注意，字段名或者局部变量名和包名的冲突：因为它们优先级高于包，如果有一个名为haxe的局部变量，它们会会阻挡整个haxe包的使用。

> Special care has to be taken with ﬁeld names or local variable names that conﬂict with a package name: Since they take priority over packages, a local variable named haxe blocks off usage the entire haxe package.

**通配符导入**：Haxe允许使用 .* 使 import可以导入一个包中所有的模块、模块中的所有类型或者类型中的所有静态字段。通过以下例子重点了解此类导入操作只能覆盖同级的访问（only crosses a single level）：

> **Wildcard import** Haxe allows using .* to allow import of all modules in a package, all types in a module or all static ﬁelds in a type. It is important to understand that this kind of import only crosses a single level as we can see in the following example:

```haxe
import haxe.macro.*; 

class Main { 
    static function main() {
        var expr:Expr = null; 
        //var expr:ExprDef = null; // Class not found : ExprDef 
    }
} 
```

使用通配符到haxe.macro的导入，使这个包中的 Expr 模块可以被访问，但是它**不能使 Expr 模块的子类型 ExprDef 被访问**。这个规则当一个模块被导入时也扩展到静态字段。

> Using the wildcard import on haxe.macro allows accessing Expr which is a module in this package, but it does not allow accessing ExprDef which is a sub-type of the Expr module. This rule extends to static ﬁelds when a module is imported.

当使用通配符导入一个包，编译器并不会立即处理包中的所有模块。这意味着这些模块除非被明确使用否则不会被作为输出的一部分生成。

> When using wildcard imports on a package, the compiler does not eagerly process all modules in that package; modules that have not been used explicitly are not part of the generated output.

**使用别名导入** 如果一个类型或静态字段在一个导入它的模块中经常使用，可以为它引入别名为一个简短的名字。这也可以用来通过给定一个唯一的标识符来消除命名冲突。

> **Import with alias** If a type or static ﬁeld is used a lot in an importing module it might help to alias it to a shorter name. This can also be used to disambiguate conﬂicting names by giving them a unique identiﬁer.

```haxe
import String.fromCharCode in f; 

class Main { 
    static function main() {
        var c1 = f(65); 
        var c2 = f(66);
        trace(c1 + c2); // AB 
    }
} 
```

这里我们导入String.fromCharCode为 f，使我们可以使用 f(65) 和 f(66)。达到和局部变量一样的使用，这个方法是编译时功能，不会有运行时开销。

> Here we import String.fromCharCode as f which allows us to use f(65) and f(66). While the same could be achieved with a local variable, this method is compile-time exclusive and guaranteed to have no run-time overhead.

**从Haxe3.2.0后 ，Haxe允许使用更自然的 as 替代 in **。

> **Since Haxe 3.2.0**
>  Haxe also allows the more natural as in place of in.