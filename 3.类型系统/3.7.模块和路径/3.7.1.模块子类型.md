# 3.7.1.模块子类型

模块子类型是一个模块中与模块不同名的类型。这使得一个 .hx 文件中可以包含多个类型声明，这些类型可以在该模块中不受限制地被调用，但从其它模块中使用时需通过 `package.Modoule.Type` 的形式进行访问:

> A module sub-type is a type declared in a module with a different name than that module. This allows a single .hx ﬁle to contain multiple types, which can be accessed unqualiﬁed from within the module, and by using package.Module.Type from other modules:

```haxe
var e:haxe.macro.Expr.ExprDef; 
```

此处访问了 `haxe.macro.Expr` 模块中的模块子类型 `ExprDef`。

模块子类型的声明可能看起来如下所示：

```haxe
// a/A.hx
package a;

class A { public function new() {} }
// sub-type
class B { public function new() {} }
```

```haxe
// Main.hx
import a.A;
class Main {
    static function main() {
        var subtype1 = new a.A.B();
        
        // these are also valid, but require import a.A or import a.A.B
        var subtype2 = new B();
        var subtype3 = new a.B();
    }
}
```

模块子类型的关系不会反映于运行时；一个修饰为 public 的模块子类型会被认为是其所在的包（package）的一个成员，比如在上面的例子中，模块子类型 `ExprDef` 会被生成为 `haxe.macro.ExprDef`。所以当一个包中存在两个模块，且两个模块中定义了同名的模块子类型时可能会产生冲突。通常，Haxe编译器会侦测到这类情况并做出相应报告。

模块子类型也可以被声明为私有的（private）：

```haxe
private class C {...}
private enum E {...}
private typedef T {...}
private abstract A {...}
```



> **定义：私有类型**
> 一个类型可以通过 `private` 访问修饰符被声明为私有。这会导致这个类型只能从定义它的这个模块内部直接进行访问。私有类型不像公开类型，不会成为它们所在的包的成员。
> *Deﬁnition: Private type*
> *A type can be made private by using the private modiﬁer. As a result,the type can only be directly accessed from within the module (3.7) it is deﬁned in. Private types, unlike public ones, do not become a member of their containing package.*

类型的可访问性可以通过访问控制（第6.10节）进行更精确地控制。

*The accessibility of types can be controlled more precisely by using [access control](https://haxe.org/manual/lf-access-control.html).*