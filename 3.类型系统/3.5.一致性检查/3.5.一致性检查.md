# 3.5.一致性检查

一致性检查 是 Haxe 类型系统的核心，其为Haxe程序极大地提升了健壮性（或称鲁棒性）。它描述了某一个类型与另一个类型是否兼容的过程。

> Uniﬁcation is the heart of the type system and contributes immensely to the robustness of Haxe programs. It describes the process of checking if a type is compatible to another type.

**一致性检查**

> 定义：一致性
> 类型A 与类型 B 之间的一致性检查是一个定向过程，它会回答一个问题：A 是否可以被赋值给 B。当两者中有一个 是/含有 单形（monomorph) (2.9) 时，其类型将在一致性检查过程中产生畸变（mutate）
>
> [warning] Deﬁnition: Uniﬁcation
> Uniﬁcation between two types A and B is a directional process which answers the question if A can be assigned to B. It may mutate either type if it is or has a monomorph (2.9).

一致性错误非常容易被触发：

> Uniﬁcation errors are very easy to trigger:

```haxe
 class Main { 
    static public function main() { 
        // Int should be String 
        var s:String = 1; 
    }
} 
```

当我们尝试分配一个 `Int` 类型的值给一个 `String` 类型变量时，会导致编译器尝试 **把 `Int` 统一为 `String`**。当然，这是不允许的并且会使编译器发出一个错误 “Int should be String”。

> We try to assign a value of type Int to a variable of type String, which causes the compiler to try and unify Int with String. This is, of course, not allowed and makes the compiler emit the error Int should be String.

在这个特殊的例子中，一致性检查在 **赋值** 操作时被触发，前文中的 “...是否可以被赋值给...” 的定义在此例中很直观，但这只是会执行一致性检查的其中一例：

> In this particular case, the uniﬁcation is triggered by an assignment, a context in which the “is assignable to” deﬁnition is intuitive. It is one of several cases where uniﬁcation is performed:

**赋值**：如果 a 被分配给 b，类型 a 会统一为 类型 b 。

> **Assignment**: If `a` is assigned to `b`, the type of `a` is uniﬁed with the type of `b`.

**函数调用**：我们在介绍 函数类型 时已经看过一个简要的例子了。通常，编译器会尝试把第一个实际参数的类型统一为第一个形式参数的类型、把第二个实际参数类型统一为第二个形式参数的类型...以此类推。

> **Function call**: We have brieﬂy seen this one while introducing thefunction(2.6)type. In general, the compiler tries to unify the ﬁrst given argument type with the ﬁrst expected argument type, the second given argument type with the second expected argument type and so on until all argument types are handled.

**函数返回**：不论函数何时出现 `return e` 表达式，`e` 的类型都会被统一为函数的返回类型。如果函数没有显式地声明返回类型，则返回类型会被推断为 `e` 的类型 且 随后的 `return` 表达式都会以该类型进行推断。

> **Function return**: Whenever a function hasa return e expression, thetypeof e is uniﬁed with the function return type. If the function has no explicit return type,it is inferred to the type of e and subsequent `return` expressions are inferred against it.

**数组声明**：编译器会尝试在一个数组声明的所有给定的类型中寻找一个最小化类型。请参阅 通用基本类型（第3.5.5节）了解更多细节。

> **Array declaration:** The compiler tries to ﬁnd a minimal type between all given types in an array declaration. Refer to Common Base Type (Section 3.5.5) for details.

**对象声明**：如果一个对象被分配了一个与声明时所不同的类型，那么编译器会把所有给定类型的字段的类型统一为期望类型的字段的类型。

> **Object declaration**: If an object is declared “against” a given type, the compiler uniﬁes each given ﬁeld type with each expected ﬁeld type.

**操作符一致性检查**：某一操作符会期望作用于某一种类型上，当操作符作用于某一类型时该类型会被统一为操作符期望的类型，比如，表达式 `a && b` 会把 `a` 和 `b` 都统一为 `Bool` 类型， 而表达式 `a == b` 会把 `a` 统一为 `b`。

> **Operator uniﬁcation**: Certain operators expect certain types which the given types are uniﬁed against. For instance, the expression a && b uniﬁes both a and b with Bool and the expression a == b uniﬁes a with b.